#' Make alphas
#'
#' Stipulated alpha values override prior_distribution
#' @param model A model object generated by \code{make_model()}.
#' @param alphas A numeric vector. Hyperparameters of the Dirichlet distribution to be passed to \code{make_priors()}.
#' @export

make_alphas <- function(model, alphas = NULL ){

	if(is.null(model$P)) 	{model  <- set_parameter_matrix(model)}
	P                  <- model$P
	return_alphas      <- alphas
	par_names          <- get_parameter_names(P)
	alpha_names        <- names(unlist(alphas))
	pars_in_alpha      <- alpha_names %in% par_names

  # if alpha is defined as vector of queries alphas <- c(`(Y[X=1] == Y[X=0])`  = 3,  `X == 1` = 3  )
  if(is.numeric(alphas) & !is.null(alpha_names)){
  	return_alphas  <-   query_to_parameters(model,	 alphas)
  }


	# if alpha contain other than parameter names e.g alphas = list(X = c(X0 = 2, `X == 1` = 3))
  if(is.list(alphas)  & any(! pars_in_alpha)){
  # Prep and translate alpha
 	i_queries <- which(!pars_in_alpha)
 	alpha_query <- unlist(alphas)[i_queries]
 	queries <- names(alpha_query)
  names(alpha_query) <- 	sapply(queries, function(q){
  	stop <- gregexpr("\\.", q, perl = TRUE)[[1]][1]
  	substr(q, stop + 1, nchar(q))
  })

 	translated_alphas  <-  query_to_parameters(model, alpha_query)

 	# Lines below check for discrepancies
 	# ok alphas(Y = c(Y00 = 1, `(Y[X=1] == Y[X=0])` = 1)
 	# error  alphas(Y = c(Y00 = 2, `(Y[X=1] == Y[X=0])` = 1) --two arguments pointing at the same parameter
 	error_message <- any_discrepancies(alphas, translated_alphas)
  if(!is.null(error_message))	{
  	stop("\n Please solve the following discrepancies \n", paste(error_message))
  }
 	# Get alphas that were specificied as par_names as opposed to queries
 	alpha_param <- sapply(alphas, function(a){
 		a[names(a) %in% rownames(P)]
 	}, simplify = FALSE)

 	# combine translated alphas and alpha_parameters by parameter set
 	return_alphas <- combine_lists(list1 = alpha_param, list2 =translated_alphas)
 }
  return_alphas
}


#' Make priors
#'
#' @param model A model created by \code{make_model()}
#' @param prior_distribution A character indicating the prior distribuiton
#' @param alphas the hyperparameters of the dirichlet distribution.
#' Stipulated alpha values override prior_distribution
#' @export
#' @examples
#' model <- make_model("X -> Y")
#' # Default sets all priors to 1
#' make_priors(model = model)
#' # Set all priors to 0.5
#' make_priors(model = model, prior_distribution = "jeffreys")
#' # Set all priors to infinity
#' make_priors(model = model, prior_distribution = "certainty")
#' # Set all priors to 1 except for prior of nodal_type X0
#' make_priors(model = model, alphas = list(X = c(X0 = 2)))
#' # Specify priors by query
#'  make_priors(model = model,
#'              alphas = c(`(Y[X=1] == Y[X=0])`  = 3,  `X == 1` = 3))
#' # Specify priors for each of the nodal_types in model
#' make_priors(model = model,
#'  alphas = list(X = c(X0 = 2, `X == 1` = 3),
#'  Y = c(`(Y[X=1] > Y[X=0])` = 3,
#'  Y10 = 2, `(Y[X=1] == Y[X=0])` = 3)))
#' # set all priors to 10
#' make_priors(model = model, alphas =  10)
#' # If the prior for a given parameter is duplicated,
#' # make_prior() throws an informative error.
#' \dontrun{
#' make_priors(model = model,
#'   alphas = list(X = c(X0 = 2, `X == 1` = 3),
#'     Y = c(Y00 = 1, `(Y[X=1] > Y[X=0])` = 3,
#'     Y01 = 2, `(Y[X=1] == Y[X=0])`  = 3)))
#' }
#' library(dplyr)
#' # Priors of confounded models
#' model <- make_model("X -> Y") %>%
#' set_confound(list(X = "(Y[X=1]>Y[X=0])"))
#'
#' # Simultaneously set priors for confound and nonconfound parameters.
#' make_priors(model = model,  alphas =  c(`(X == 0)`  = 2))
#' # To target variable modeling confound, specify the condition
#' # that determines the confounded relationship between variables
#' make_priors(model = model,  alphas =  c(`(X == 0) & (Y[X=1]>Y[X=0])` = 2))
make_priors  <- function(model,  prior_distribution = "uniform", alphas = NULL){

	if(!is.null(prior_distribution)){
		if(!(prior_distribution %in% c("uniform", "jeffreys", "certainty")))
				stop("prior_distribution should be either 'uniform', 'jeffreys', or 'certainty'.")
	}

	#if(is.null(model$P)) {model  <- set_parameter_matrix(model)}
	# P          <- get_parameter_matrix(model)
	par_names  <- get_parameter_names(model = model)
	n_params   <- length(par_names)
  alphas     <- make_alphas(model, alphas)


	# alpha housekeeping
	alphas_vector <- unlist(alphas)
	n_alphas      <- length(alphas_vector)
	alpha_names   <- names(alphas_vector)

	if(is.null(prior_distribution) & ((n_alphas!=1 & n_alphas!=n_params)))	stop(
		"if prior_distribution is not specified, alphas must contain either a value
		for each parameter or a single value to be assigned to all parameters.")


	if(n_alphas == 1 & is.null(alpha_names)){
		alphas_vector <- rep(alphas, n_params)
		names(alphas_vector) <- alpha_names   <- par_names
	}


	# Check that alpha names match par names
	not_in_dag <- !alpha_names %in% par_names
	if(any(not_in_dag )){
		index <- which(not_in_dag)
		error_text	<- sapply(index, function(i){

			reversed_name <- sapply(lapply(strsplit(alpha_names[i], NULL), rev), paste, collapse = "")
			splitted_name <- unlist( strsplit(sub("[.]", ";", reversed_name), ";"))

			paste0("\n variable ", splitted_name[2], " and corresponding nodal_type ",
						 splitted_name[1], " must match variables in dag and nodal_types syntax")

		})
		stop(	error_text )}

	# Check alpha strictly positive
	if(any(	alphas_vector  <= 0)) stop("alphas must be strictly positive real numbers")

	# Calculate priors
	if(!is.null(prior_distribution)){
		if(prior_distribution == "uniform")   priors <- rep(1, n_params )
		if(prior_distribution == "jeffreys")  priors <- rep(0.5, n_params )
		if(prior_distribution == "certainty") priors <- rep(10000, n_params )

	} else{
		if(n_alphas == 1)                     priors <- rep(alphas, n_params)
		if(n_alphas == n_params)              priors <- alphas}

	# Substitute alpha vector when provided
	names(priors)       <- par_names
	priors[alpha_names] <- alphas_vector

	# result
	names(priors)       <- par_names
	priors

}



#' Set prior distribution
#'
#' Set prior distribution. Use \code{make_alphas} to use causal types to indicate priors.
#' @param model A model object generated by \code{make_model()}.
#' @param priors A numeric vector. Dirichlet hyperparameters.
#' @param prior_distribution A character string. Indicates the prior distribution to be used. Can be 'uniform', 'jeffreys', or 'certainty'.
#' @param alphas A numeric vector. Hyperparameters of the Dirichlet distribution to be passed to \code{make_priors()}.
#' @export
#' @examples
#'
#' library(dplyr)
#' model <- make_model("X -> Y") %>%
#'   set_priors(
#'            alphas = list(
#'              X = c(`X == 1` = 3),
#'              Y = c(`(Y[X=1] != Y[X=0])` = 3)))
#'model$priors
#'
#'model <- make_model("X -> Y") %>%
#' set_priors(prior_distribution = "jeffreys")
#' model$priors
#'
#'model <- make_model("X -> Y") %>%
#' set_priors(1:6)
#' model$priors


set_priors  <- function(model,
												priors = NULL,
												prior_distribution=NA,
												parameter_set=NA,
												statement=NA,
												confound=NA,
												alphas=NULL,
												label=NA) {

	if(is.null(priors)) priors <- make_priors2(model,
																						 prior_distribution=prior_distribution,
																						 parameter_set=parameter_set,
																						 statement=statement,
																						 confound=confound,
																						 alphas=alphas,
																						 label=label)

   model$priors  <- check_priors(priors, model = model) # Checks non negativity and adds names if missing

   model

}



#' Get prior distribution
#'
#' @param model A model object generated by make_model().
#' @param priors A numeric vector. Dirichlet hyperparameters.
#' @param prior_distribution A character vector. Indicates the prior distribution to be used. Can be 'uniform', 'jeffreys', or 'certainty'.
#' @param alphas A numeric vector. Hyperparameters of the Dirichlet distribution to be passed to \code{make_priors()}.
#'
#' @export

get_priors  <- function(model,
												priors = NULL,
												prior_distribution=NA,
												parameter_set=NA,
												statement=NA,
												confound=NA,
												alphas=NULL,
												label=NA) {

	if(!is.null(model$priors)) return(model$priors)

	message(paste("Priors missing from model. Generated on the fly."))
	make_priors2(model,
							 prior_distribution=prior_distribution,
							 parameter_set=parameter_set,
							 statement=statement,
							 confound=confound,
							 alphas=alphas,
							 label=label)

}


#' Add prior distribution draws
#'
#' Add n_param x n_draws database of possible lambda draws to the model.
#'
#' @param model A model object generated by make_model().
#' @param n_draws A scalar. Number of draws.
#' @export
#'
set_prior_distribution <- function(model, n_draws = 4000) {

  if(is.null(model$priors)) model <- set_priors(model)
  if(is.null(model$P)) model <- set_parameter_matrix(model)

  model$prior_distribution <- t(replicate(n_draws, draw_parameters(model)))
#  message(paste("Prior distribution based on", n_draws, "draws attached to model"))

	return(model)
}

#' Get names of groups in param_set
#'
#' @param model A model
#' @examples
#' library(dplyr)
#' \dontrun{
#' make_model("X -> Y") %>%
#'  set_confound(list(X = "Y[X=1]>Y[X=0]"))  %>%
#'  get_param_set_names()}

get_param_set_names <- function(model){

	if(is.null(attr(model$P, "confounds"))) return(model$variables)

  unique(attr(model$P,"param_set"))
	}


#' Check parameters sum to 1 in paramset; normalize if needed; add names if needed
#'
#' @param parameters A vector of probabilities, summing to 1 within each parameter set.
#' @param param_set_names Names of parameter sets. Param names begin with param_set_names followed by a period. For instaicen "X.X0".
#' @param warning Logical whether to print warning (if any) in console.
#' @param model A model object generated by \code{make_model()}.
#' @examples
#' \dontrun{
#' check_params(rep(1,6), param_set_names = c("X", "Y"), warning = TRUE)
#' check_params(rep(1,6), param_set_names = c("X", "Y"), model = make_model("X->Y"))
#' check_params(rep(1,6), param_set_names = c("X", "Y"), model = make_model("X->Y"), warning = TRUE)

#' }

check_params <- function(parameters, param_set_names, warning = FALSE, model = NULL){

	# Add param names if missing
	if(is.null(names(parameters))){
		if(is.null(model)) stop("Parameter names missing, please provide model to check_params")
		param_names <- get_parameter_names(model = model)
		if(length(parameters) != length(param_names)) stop("Parameters incorrect length")
	  names(parameters)	<- param_names}

	# Normalize
	for (j in param_set_names) {
		x <- startsWith(names(parameters), paste0(j, "."))
		if(!isTRUE(all.equal(sum(parameters[x]), 1)) ){
			if(warning) message(paste0("Parameters in set ", j, " do not sum to 1. Using normalized parameters"))
			parameters[x] <- parameters[x] / sum(parameters[x])
		}
	}
	parameters
	}


#' Check priors are non negative and adds names if needed
#' @param priors a prior vector; one non negative scalar per parameter
#' @param model a model; required if priors are missing names
#' @examples
#' \dontrun{check_priors(make_model("X->Y")$priors)
#' check_priors(rep(1,6), make_model("X->Y"))}

check_priors <- function(priors, model = NULL){

	if(min(priors) < 0 ) stop("Negative alpha arguments for priors are not allowed")

	# Add names if missing
	if(is.null(names(priors))){
		if(is.null(model)) stop("Priors names missing, please provide model to check_priors")
		priors_names <- get_parameter_names(model = model)
		if(length(priors) != length(priors_names)) stop("Priors incorrect length")
		names(priors)	<- priors_names}

	priors
}

#' Add a true parameter vector
#'
#' Add a vector of "true" parameters to a model.
#'
#' @param model A model generated by \code{make_model}.
#' @param parameters A numeric vector. Parameters to add to model.
#' @param type A character string specifying type of parameters to set ("flat", "prior_mean", "posterior_mean", "prior_draw", "posterior_draw", "define). With type set to \code{define} use arguments to be passed to \code{make_priors}; otherwise \code{flat} sets equal probabilities on each nodal type in each parameter set; \code{prior_mean}, \code{prior_draw}, \code{posterior_mean}, \code{posterior_draw} take parameters as the means or as draws from the prior or posterior.
#' @param ... Options passed onto \code{make_priors()}.
#' @importFrom rstan extract
#' @export
#' @examples
#' model <- make_model("X -> Y")
#' get_parameters(model)
#' set_parameters(model, parameters = c(.25, .75, 1.25,.25, .25, .25))$parameters
#' set_parameters(make_model("X -> Y"), type = "flat")$parameters
#'
#' # Use make_alpha to define specific parameters using causal syntax
#' model <- set_parameters(make_model("X -> Y"), type = 'define',
#'                         alphas = list(Y = c(`(Y[X=1] > Y[X=0])` = 3)))
#' model$parameters
set_parameters <- function(model,
													 parameters = NULL,
													 type = "prior_mean",
													 ...) {

	# param_set names
	param_set_names <- get_param_set_names(model)

  # If parameters provided, clean and use these and then exit
	if(!is.null(parameters)){
     parameters   <- check_params(parameters, param_set_names, warning = TRUE, model = model)
     model$parameters <- parameters
     return(model)
     }

	# Flat lambda
	if (type == "flat")  {
		parameters <- make_priors(model, prior_distribution = "uniform")
		parameters <- check_params(parameters, param_set_names)
	 }

	# New (from alpha)
	if (type == "define") {
		parameters <- make_priors(model, ...)
		parameters <- check_params(parameters, param_set_names)
   }

	# Prior mean
	if (type == "prior_mean") {
		if (is.null(model$prior)) stop("Prior distribution required")
		parameters <- check_params(model$priors, param_set_names)
		}

	# Prior draw
	if (type == "prior_draw") {
			if (is.null(model$prior)) stop("Prior distribution required")
			parameters <- draw_parameters(model)
			}

	if (type == "posterior_mean") {
			if (is.null(model$posterior)) stop("Posterior distribution required")
			parameters <- apply(extract(model$posterior, pars = "lambdas")$lambdas, 2, mean)
			}

	if (type == "posterior_draw") {
			if (is.null(model$posterior)) stop("Posterior distribution required")
			df <- extract(model$posterior, pars = "lambdas")$lambdas
			parameters <- df[sample(nrow(df), 2),]
			}

		model$parameters <- parameters

		return(model)
}


#' Get parameters
#'
#' @param model A model object generated by make_model().
#' @param ... Arguments taken by set_parameters
#'
#' @export
#' @examples
#' get_parameters(make_model("X -> Y"))

get_parameters  <- function(model,  ...) {

	if(!is.null(model$parameters)) return(model$parameters)

	message(paste("Parameters missing from model. Generated on the fly."))
	set_parameters(model, ...)$parameters

}

